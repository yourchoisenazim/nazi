<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Image Animator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @keyframes gradient {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      body {
        background: linear-gradient(-45deg, #f83bff, #b325ff, #3225ff, #25b3ff);
        background-size: 400% 400%;
        animation: gradient 15s ease infinite;
      }
    </style>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.1.1",
    "react-dom/client": "https://esm.sh/react-dom@^19.1.1/client",
    "@google/genai": "https://esm.sh/@google/genai@^1.14.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/"
  }
}
</script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module">
import React, { useState, useEffect, useCallback, useRef, createContext, useContext } from 'react';
import ReactDOM from 'react-dom/client';
import { GoogleGenAI } from "@google/genai";

// --- From types.ts ---
const AppStatus = {
  IDLE: 0,
  UPLOADING: 1,
  GENERATING: 2,
  SUCCESS: 3,
  ERROR: 4,
};

// --- From i18n.ts ---
const translations = {
  en: {
    appTitle: 'AI Image Animator',
    appSubtitle: 'Transform static images into dynamic videos with AI.',
    uploadCTA: 'Click to upload an image',
    uploadHint: 'PNG or JPG',
    promptLabel: 'Animation Prompt',
    promptPlaceholder: 'e.g., A photorealistic car driving down a sun-drenched road, cinematic...',
    animateButton: 'Animate Image',
    footerText: 'Powered by Gemini. Create amazing video animations from a single image.',
    errorFileRead: 'Failed to read the image file.',
    errorMissingInputs: 'Please upload an image and provide an animation prompt.',
    errorUnknown: 'An unknown error occurred during video generation.',
    errorSafety: 'The request was blocked due to safety policies. Please try a different image or prompt.',
    errorQuota: "You've exceeded your API quota. Please check your plan and billing details, and try again later.",
    animationFailed: 'Animation Failed',
    tryAgainButton: 'Try Again',
    loadingTitle: 'Animating Your Image',
    loadingMsg1: "Warming up the AI's imagination...",
    loadingMsg2: 'Gathering stardust and moonbeams...',
    loadingMsg3: 'Teaching pixels how to dance...',
    loadingMsg4: 'This can take a minute, great art needs patience.',
    loadingMsg5: 'Composing a symphony of motion...',
    loadingMsg6: 'Unleashing creative digital energy...',
    loadingMsg7: 'Almost there, the magic is happening!',
    successTitle: 'Animation Complete!',
    downloadButton: 'Download Video',
    createAnotherButton: 'Create Another',
  },
  es: {
    appTitle: 'Animador de Imágenes IA',
    appSubtitle: 'Transforma imágenes estáticas en videos dinámicos con IA.',
    uploadCTA: 'Haz clic para subir una imagen',
    uploadHint: 'PNG o JPG',
    promptLabel: 'Instrucción de Animación',
    promptPlaceholder: 'Ej: Un coche fotorrealista conduciendo por una carretera soleada, cinemático...',
    animateButton: 'Animar Imagen',
    footerText: 'Creado con Gemini. Crea increíbles animaciones de video a partir de una sola imagen.',
    errorFileRead: 'Error al leer el archivo de imagen.',
    errorMissingInputs: 'Por favor, sube una imagen y proporciona una instrucción de animación.',
    errorUnknown: 'Ocurrió un error desconocido durante la generación del video.',
    errorSafety: 'La solicitud fue bloqueada por políticas de seguridad. Por favor, intenta con una imagen o instrucción diferente.',
    errorQuota: 'Has excedido tu cuota de API. Por favor, revisa tu plan y detalles de facturación, e inténtalo de nuevo más tarde.',
    animationFailed: 'Falló la Animación',
    tryAgainButton: 'Intentar de Nuevo',
    loadingTitle: 'Animando Tu Imagen',
    loadingMsg1: 'Calentando la imaginación de la IA...',
    loadingMsg2: 'Recolectando polvo de estrellas y rayos de luna...',
    loadingMsg3: 'Enseñando a los píxeles a bailar...',
    loadingMsg4: 'Esto puede tardar un minuto, el gran arte necesita paciencia.',
    loadingMsg5: 'Componiendo una sinfonía de movimiento...',
    loadingMsg6: 'Liberando energía digital creativa...',
    loadingMsg7: '¡Casi listo, la magia está sucediendo!',
    successTitle: '¡Animación Completa!',
    downloadButton: 'Descargar Video',
    createAnotherButton: 'Crear Otro',
  },
  fr: {
    appTitle: "Animateur d'Image IA",
    appSubtitle: "Transformez des images statiques en vidéos dynamiques avec l'IA.",
    uploadCTA: 'Cliquez pour télécharger une image',
    uploadHint: 'PNG ou JPG',
    promptLabel: "Instruction d'Animation",
    promptPlaceholder: "Ex: Une voiture photoréaliste roulant sur une route ensoleillée, cinématique...",
    animateButton: "Animer l'Image",
    footerText: "Propulsé par Gemini. Créez d'incroyables animations vidéo à partir d'une seule image.",
    errorFileRead: "Échec de la lecture du fichier image.",
    errorMissingInputs: "Veuillez télécharger une image et fournir une instruction d'animation.",
    errorUnknown: "Une erreur inconnue s'est produite lors de la génération de la vidéo.",
    errorSafety: "La demande a été bloquée pour des raisons de sécurité. Veuillez essayer une autre image ou une autre instruction.",
    errorQuota: "Vous avez dépassé votre quota d'API. Veuillez vérifier votre forfait et vos informations de facturation, puis réessayez plus tard.",
    animationFailed: "L'animation a Échoué",
    tryAgainButton: 'Réessayer',
    loadingTitle: 'Animation de Votre Image',
    loadingMsg1: "Réchauffement de l'imagination de l'IA...",
    loadingMsg2: 'Collecte de poussière d’étoiles et de rayons de lune...',
    loadingMsg3: 'Apprendre aux pixels à danser...',
    loadingMsg4: 'Cela peut prendre une minute, le grand art demande de la patience.',
    loadingMsg5: 'Composition d’une symphonie du mouvement...',
    loadingMsg6: 'Libération de l’énergie numérique créative...',
    loadingMsg7: 'Presque terminé, la magie opère !',
    successTitle: 'Animation Terminée !',
    downloadButton: 'Télécharger la Vidéo',
    createAnotherButton: 'Créer une Autre',
  },
};
const getInitialLocale = () => {
  if (typeof window === 'undefined') return 'en';
  const browserLang = navigator.language.split(/[-_]/)[0];
  return browserLang in translations ? browserLang : 'en';
};
const LocaleContext = createContext(undefined);
const LocaleProvider = ({ children }) => {
  const [locale, setLocale] = useState(getInitialLocale());
  const t = (key) => {
    return translations[locale]?.[key] || translations['en'][key] || key;
  };
  const availableLocales = Object.keys(translations);
  const loadingMessagesKeys = [
    'loadingMsg1', 'loadingMsg2', 'loadingMsg3', 'loadingMsg4', 'loadingMsg5', 'loadingMsg6', 'loadingMsg7'
  ];
  const value = { locale, setLocale, t, availableLocales, loadingMessagesKeys };
  return React.createElement(LocaleContext.Provider, { value }, children);
};
const useLocale = () => {
  const context = useContext(LocaleContext);
  if (context === undefined) {
    throw new Error('useLocale must be used within a LocaleProvider');
  }
  return context;
};

// --- From services/geminiService.ts ---
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
const isSafetyError = (error) => {
    const message = error?.error?.message || error?.message || '';
    const lowerMessage = String(message).toLowerCase();
    return lowerMessage.includes('sensitive') || 
           lowerMessage.includes('responsible ai practices') || 
           lowerMessage.includes('safety policies') ||
           lowerMessage.includes('usage guidelines');
};
const generateVideoFromImage = async (base64ImageData, mimeType, prompt) => {
    console.log("Starting video generation...");
    const modifiedPrompt = `${prompt}, photorealistic, cinematic, high detail, 3 second video`;
    let operation;
    let attempt = 0;
    const maxRetries = 6;
    const baseDelay = 4000;
    while (attempt < maxRetries) {
        try {
            operation = await ai.models.generateVideos({
                model: 'veo-2.0-generate-001',
                prompt: modifiedPrompt,
                image: {
                    imageBytes: base64ImageData,
                    mimeType: mimeType,
                },
                config: {
                    numberOfVideos: 1,
                }
            });
            break; // Success
        } catch (error) {
            attempt++;
            const isRateLimitError = error?.error?.status === 'RESOURCE_EXHAUSTED' || String(error).includes('429');
            const isServerError = error?.error?.code === 500 || error?.error?.status === 'UNKNOWN';
            const shouldRetry = isRateLimitError || isServerError;
            if (!shouldRetry || attempt >= maxRetries) {
                console.error(`Failed to start video generation. Final attempt failed:`, error);
                if (isSafetyError(error)) {
                    throw new Error("SAFETY_ERROR");
                }
                if (isRateLimitError) {
                    throw new Error("QUOTA_ERROR");
                }
                const errorMessage = error?.error?.message || "The service is currently busy. Please try again in a moment.";
                throw new Error(errorMessage);
            }
            const backoffDelay = baseDelay * Math.pow(2, attempt - 1) + (Math.random() * 1000);
            console.warn(`Initial generation call failed (${isRateLimitError ? 'rate limit' : 'server error'}). Retrying in ${Math.round(backoffDelay / 1000)}s... (Attempt ${attempt}/${maxRetries})`);
            await new Promise(resolve => setTimeout(resolve, backoffDelay));
        }
    }
    if (!operation) {
        throw new Error("Failed to start video generation after multiple attempts.");
    }
    console.log("Operation started, polling for result...");
    const initialPollInterval = 10000;
    let currentPollInterval = initialPollInterval;
    const maxPollRetries = 8;
    let pollRetryCount = 0;
    while (!operation.done) {
        await new Promise(resolve => setTimeout(resolve, currentPollInterval));
        try {
            operation = await ai.operations.getVideosOperation({ operation: operation });
            console.log(`Polling... operation status: ${operation.done ? 'done' : 'in progress'}`);
            pollRetryCount = 0; // Reset count on success
            currentPollInterval = initialPollInterval;
        } catch (error) {
            console.error("Error during polling:", error);
            const isRateLimitError = error?.error?.status === 'RESOURCE_EXHAUSTED' || String(error).includes('429');
            const isServerError = error?.error?.code === 500 || error?.error?.status === 'UNKNOWN';
            const shouldRetry = isRateLimitError || isServerError;
            if (shouldRetry) {
                pollRetryCount++;
                if (pollRetryCount > maxPollRetries) {
                    throw new Error("The service is still busy after several attempts. Please wait a few minutes and try again.");
                }
                currentPollInterval = initialPollInterval * Math.pow(2, pollRetryCount -1) + (Math.random() * 1000);
                console.warn(`Polling failed (${isRateLimitError ? 'rate limit' : 'server error'}). Retrying in ${Math.round(currentPollInterval / 1000)} seconds... (Attempt ${pollRetryCount}/${maxRetries})`);
            } else {
                const errorMessage = error?.error?.message || "An unexpected error occurred while checking the video status.";
                throw new Error(errorMessage);
            }
        }
    }
    console.log("Video generation complete.");
    if (operation.error) {
        console.error("Video generation operation failed:", operation.error);
        if (isSafetyError(operation.error)) {
            throw new Error("SAFETY_ERROR");
        }
        const errorMessage = operation.error.message || "The video generation failed after processing.";
        throw new Error(errorMessage);
    }
    const generatedVideos = operation.response?.generatedVideos;
    if (!generatedVideos || generatedVideos.length === 0) {
        console.error("No videos found in operation response:", operation);
        throw new Error("The AI finished but did not produce a video. This can happen due to safety filters or if the request is unclear. Please try a different image or prompt.");
    }
    const downloadLink = generatedVideos[0]?.video?.uri;
    if (!downloadLink) {
        console.error("No download link found in the first video result:", operation);
        throw new Error("Video generation completed, but the result was malformed and did not contain a download link.");
    }
    console.log("Fetching video from download link:", downloadLink);
    const response = await fetch(`${downloadLink}&key=${process.env.API_KEY}`);
    if (!response.ok) {
        const errorText = await response.text();
        console.error("Failed to download video. Status:", response.status, "Body:", errorText);
        throw new Error(`Failed to download the generated video. Status: ${response.status}`);
    }
    const videoBlob = await response.blob();
    const videoUrl = URL.createObjectURL(videoBlob);
    console.log("Video downloaded and local URL created.");
    return { url: videoUrl, blob: videoBlob };
};

// --- From components/Icons.tsx ---
const FilmIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-10 w-10 text-indigo-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2 },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M7 4v16M17 4v16M3 8h4m10 0h4M3 12h18M3 16h4m10 0h4M4 20h16a1 1 0 001-1V5a1 1 0 00-1-1H4a1 1 0 00-1 1v14a1 1 0 001 1z" })
    )
);
const PhotoIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-12 w-12 text-slate-500", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5 },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" })
    )
);
const PlayCircleIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", className: "w-6 h-6" },
        React.createElement('path', { fillRule: "evenodd", d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zm14.024-.983a1.125 1.125 0 010 1.966l-5.603 3.113A1.125 1.125 0 019 15.113V8.887c0-.857.921-1.4 1.671-.983l5.603 3.113z", clipRule: "evenodd" })
    )
);
const ArrowPathIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", className: "w-5 h-5" },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.181-3.183m-11.664 0l3.181-3.183a8.25 8.25 0 00-11.664 0l3.181 3.183" })
    )
);
const ArrowDownTrayIcon = () => (
    React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", className: "w-5 h-5" },
        React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" })
    )
);
const LoadingSpinnerIcon = () => (
    React.createElement('svg', { className: "animate-spin h-12 w-12 text-indigo-500", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" },
        React.createElement('circle', { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
        React.createElement('path', { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })
    )
);

// --- From components/Header.tsx ---
const Header = () => {
  const { t } = useLocale();
  return React.createElement('header', { className: "text-center" },
    React.createElement('div', { className: "inline-flex items-center gap-4" },
      React.createElement(FilmIcon),
      React.createElement('h1', { className: "text-4xl sm:text-5xl font-extrabold tracking-tight" },
        React.createElement('span', { className: "bg-gradient-to-r from-purple-400 to-indigo-500 text-transparent bg-clip-text" },
          t('appTitle')
        )
      )
    ),
    React.createElement('p', { className: "mt-4 text-lg text-slate-400" }, t('appSubtitle'))
  );
};

// --- From components/ImageUploader.tsx ---
const ImageUploader = ({ onImageSelect, previewUrl, disabled }) => {
  const { t } = useLocale();
  const fileInputRef = useRef(null);
  const handleFileChange = (event) => {
    const file = event.target.files?.[0];
    if (file) {
      onImageSelect(file);
    }
  };
  const handleClick = () => {
    fileInputRef.current?.click();
  };
  return React.createElement('div', {
      onClick: handleClick,
      className: `relative w-full aspect-video border-2 border-dashed rounded-xl flex items-center justify-center text-center p-4 transition-all duration-300 ${
        disabled ? 'cursor-not-allowed bg-slate-800' : 'cursor-pointer bg-slate-800/50 hover:border-indigo-500 hover:bg-slate-800'
      } ${previewUrl ? 'border-indigo-500' : 'border-slate-600'}`
    },
    React.createElement('input', {
      type: "file",
      ref: fileInputRef,
      onChange: handleFileChange,
      accept: "image/png, image/jpeg",
      className: "hidden",
      disabled: disabled
    }),
    previewUrl ?
      React.createElement('img', { src: previewUrl, alt: "Preview", className: "max-h-full max-w-full object-contain rounded-lg" }) :
      React.createElement('div', { className: "flex flex-col items-center gap-2 text-slate-400" },
        React.createElement(PhotoIcon),
        React.createElement('p', { className: "font-semibold" }, t('uploadCTA')),
        React.createElement('p', { className: "text-sm text-slate-500" }, t('uploadHint'))
      )
  );
};

// --- From components/PromptInput.tsx ---
const PromptInput = ({ value, onChange, disabled }) => {
  const { t } = useLocale();
  return React.createElement('div', null,
    React.createElement('label', { htmlFor: "prompt", className: "block text-sm font-medium text-slate-300 mb-2" },
      t('promptLabel')
    ),
    React.createElement('textarea', {
      id: "prompt",
      value: value,
      onChange: (e) => onChange(e.target.value),
      disabled: disabled,
      placeholder: t('promptPlaceholder'),
      rows: 3,
      className: "w-full p-3 bg-slate-700/50 border border-slate-600 rounded-lg placeholder-slate-500 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-colors disabled:cursor-not-allowed disabled:bg-slate-800"
    })
  );
};

// --- From components/LoadingDisplay.tsx ---
const LoadingDisplay = () => {
  const { t, loadingMessagesKeys } = useLocale();
  const [messageKey, setMessageKey] = useState(loadingMessagesKeys[0]);
  useEffect(() => {
    const intervalId = setInterval(() => {
      setMessageKey(prevKey => {
        const currentIndex = loadingMessagesKeys.indexOf(prevKey);
        const nextIndex = (currentIndex + 1) % loadingMessagesKeys.length;
        return loadingMessagesKeys[nextIndex];
      });
    }, 3500);
    return () => clearInterval(intervalId);
  }, [loadingMessagesKeys]);
  return React.createElement('div', { className: "flex flex-col items-center justify-center p-8 gap-6 text-center" },
    React.createElement(LoadingSpinnerIcon),
    React.createElement('h2', { className: "text-2xl font-bold text-indigo-400" }, t('loadingTitle')),
    React.createElement('p', { className: "text-slate-400 min-h-[40px]" }, t(messageKey))
  );
};

// --- From components/VideoPlayer.tsx ---
const VideoPlayer = ({ src, blob, onReset }) => {
  const { t } = useLocale();
  const handleDownload = () => {
    const a = document.createElement('a');
    a.href = src;
    a.download = `animation_${Date.now()}.mp4`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };
  return React.createElement('div', { className: "flex flex-col items-center gap-6" },
    React.createElement('h2', { className: "text-2xl font-bold text-green-400" }, t('successTitle')),
    React.createElement('video', {
      src: src,
      controls: true,
      autoPlay: true,
      loop: true,
      muted: true,
      playsInline: true,
      className: "w-full rounded-lg shadow-lg border border-slate-700"
    }),
    React.createElement('div', { className: "flex flex-col sm:flex-row gap-4 w-full" },
      React.createElement('button', {
        onClick: handleDownload,
        className: "w-full inline-flex items-center justify-center gap-2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors"
      },
        React.createElement(ArrowDownTrayIcon),
        t('downloadButton')
      ),
      React.createElement('button', {
        onClick: onReset,
        className: "w-full inline-flex items-center justify-center gap-2 bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-4 rounded-lg transition-colors"
      },
        React.createElement(ArrowPathIcon),
        t('createAnotherButton')
      )
    )
  );
};

// --- From App.tsx ---
const fileToBase64 = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const result = reader.result;
      if (typeof result === 'string') {
        resolve(result.split(',')[1]);
      } else {
        reject(new Error("Could not read file as a data URL string."));
      }
    };
    reader.onerror = error => reject(error);
  });
};
const App = () => {
  const { t, locale, setLocale, availableLocales } = useLocale();
  const [imageFile, setImageFile] = useState(null);
  const [previewUrl, setPreviewUrl] = useState(null);
  const [imageBase64, setImageBase64] = useState(null);
  const [prompt, setPrompt] = useState('');
  const [generatedVideo, setGeneratedVideo] = useState(null);
  const [status, setStatus] = useState(AppStatus.IDLE);
  const [error, setError] = useState(null);
  useEffect(() => {
    if (!imageFile) {
      setPreviewUrl(null);
      return;
    }
    const objectUrl = URL.createObjectURL(imageFile);
    setPreviewUrl(objectUrl);
    return () => URL.revokeObjectURL(objectUrl);
  }, [imageFile]);
  const handleImageSelect = useCallback(async (file) => {
    setImageFile(file);
    setStatus(AppStatus.UPLOADING);
    try {
      const b64 = await fileToBase64(file);
      setImageBase64(b64);
      setStatus(AppStatus.IDLE);
    } catch (err) {
      setError(t('errorFileRead'));
      setStatus(AppStatus.ERROR);
    }
  }, [t]);
  const handleGenerate = async () => {
    if (!imageBase64 || !prompt) {
      setError(t('errorMissingInputs'));
      return;
    }
    setError(null);
    setStatus(AppStatus.GENERATING);
    setGeneratedVideo(null);
    try {
      const videoResult = await generateVideoFromImage(imageBase64, imageFile?.type || 'image/jpeg', prompt);
      setGeneratedVideo(videoResult);
      setStatus(AppStatus.SUCCESS);
    } catch (err) {
      console.error(err);
      let messageToDisplay;
      if (err instanceof Error) {
        switch (err.message) {
          case 'SAFETY_ERROR':
            messageToDisplay = t('errorSafety');
            break;
          case 'QUOTA_ERROR':
            messageToDisplay = t('errorQuota');
            break;
          default:
            messageToDisplay = err.message;
        }
      } else {
        messageToDisplay = t('errorUnknown');
      }
      setError(messageToDisplay);
      setStatus(AppStatus.ERROR);
    }
  };
  const handleReset = () => {
    setImageFile(null);
    setImageBase64(null);
    setPrompt('');
    setGeneratedVideo(null);
    setError(null);
    setStatus(AppStatus.IDLE);
  };
  const isGenerating = status === AppStatus.GENERATING;
  const renderContent = () => {
    switch (status) {
      case AppStatus.GENERATING:
        return React.createElement(LoadingDisplay);
      case AppStatus.SUCCESS:
        return generatedVideo ?
          React.createElement(VideoPlayer, { src: generatedVideo.url, blob: generatedVideo.blob, onReset: handleReset }) :
          null;
      case AppStatus.ERROR:
        return React.createElement('div', { className: "text-center p-8 bg-red-900/20 rounded-lg" },
          React.createElement('p', { className: "text-red-400 font-semibold" }, t('animationFailed')),
          React.createElement('p', { className: "mt-2 text-red-300" }, error),
          React.createElement('button', {
            onClick: handleReset,
            className: "mt-6 inline-flex items-center gap-2 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-colors"
          },
            React.createElement(ArrowPathIcon),
            t('tryAgainButton')
          )
        );
      default:
        return React.createElement('div', { className: "w-full flex flex-col gap-6" },
          React.createElement(ImageUploader, {
            onImageSelect: handleImageSelect,
            previewUrl: previewUrl,
            disabled: isGenerating
          }),
          React.createElement(PromptInput, {
            value: prompt,
            onChange: setPrompt,
            disabled: isGenerating
          }),
          React.createElement('button', {
            onClick: handleGenerate,
            disabled: !imageBase64 || !prompt || isGenerating,
            className: "w-full mt-2 inline-flex items-center justify-center gap-3 bg-indigo-600 hover:bg-indigo-700 disabled:bg-slate-600 disabled:cursor-not-allowed text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 text-lg transform active:scale-95"
          },
            React.createElement(PlayCircleIcon),
            t('animateButton')
          )
        );
    }
  };
  return React.createElement('div', { className: "min-h-screen text-gray-200 flex flex-col items-center p-4 sm:p-6" },
    React.createElement(Header),
    React.createElement('main', { className: "w-full max-w-2xl mx-auto mt-8 p-6 sm:p-8 bg-slate-800/50 rounded-2xl shadow-2xl shadow-indigo-900/20 border border-slate-700 backdrop-blur-sm" },
      renderContent()
    ),
    React.createElement('footer', { className: "text-center py-6 mt-8 text-slate-300 text-sm" },
      React.createElement('p', null, t('footerText')),
      React.createElement('div', { className: "mt-4" },
        React.createElement('select', {
          value: locale,
          onChange: (e) => setLocale(e.target.value),
          className: "bg-slate-800 border border-slate-700 rounded-md py-1 px-2 text-slate-300 text-xs focus:ring-indigo-500 focus:border-indigo-500",
          'aria-label': "Select language"
        },
          availableLocales.map((loc) => (
            React.createElement('option', { key: loc, value: loc },
              loc.toUpperCase()
            )
          ))
        )
      )
    )
  );
};

// --- From index.tsx ---
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}
const root = ReactDOM.createRoot(rootElement);
root.render(
  React.createElement(React.StrictMode, null,
    React.createElement(LocaleProvider, null,
      React.createElement(App, null)
    )
  )
);
    </script>
  </body>
</html>